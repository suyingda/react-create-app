<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
<!--<div onclick="a()">click</div>-->
<input id="inp"/>
<script>
    var ll = 1;
    Promise.resolve(10).then((value)=> {
        console.log(value); // "Success"
        ll +=10
    }).then(()=>{
        console.log(ll)
    });
/*    var a = 0
    var b = () => {
        var temp = a;
        Promise.resolve(10)
            .then((r) => {
                a = temp + r;
                console.log('进入')
            })
            .then(() => {
                console.log('2', a)
            })
    }
    b()
    a++
    console.log('1', a)*/
    /*var a = 0
    let b = async () => {
        a = a + await 10
        console.log('2', a) // -> '2' 10
    }
    b()
    a++
    console.log('1', a) // -> '1' 1*/

    /* function throttle(fn) {
         let canRun = true; // 通过闭包保存一个标记
         return function () {
             if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
             canRun = false; // 立即设置为false
             setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
                 fn.apply(this, arguments);
                 // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
                 canRun = true;
             }, 500);
         };
     }
     function sayHi(e) {
         console.log(e.target.innerWidth, e.target.innerHeight);
     }
     window.addEventListener('resize', throttle(sayHi));*/


  /*  function a() {
        var status = true
        return function () {
            if (!status) return;
            status = false
            setTimeout(function () {
                console.log(status)
                 status = true;
            }, 1000);
        }

    }
    var inp = document.getElementById('inp');
    inp.addEventListener('input', a()); // 防抖*/

    /*function debounce(fn) {
            let timeout = null; // 创建一个标记用来存放定时器的返回值
            return function () {
                clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
                timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
                    fn.apply(this, arguments);
                }, 500);
            };
        }

        function sayHi() {
            console.log('successful');
        }*/


    /*  // instanceof
      var arr = function() {

      };
      console.log(arr.__proto__ === Function.prototype)
      console.log(arr instanceof Function); // true */

    // var scope = "global scope";

    // function checkscope() {
    //     var scope = "local scope";

    //     function f() {
    //         console.log(scope);
    //     }
    //     return f;
    // }

    // var foo = checkscope(); // foo指向函数f
    // foo()
    //
    // function cloneShallow(source) {
    //     var target = {};
    //     for (var key in source) {
    //         // if (Object.prototype.hasOwnProperty.call(source, key)) {
    //         if (source.hasOwnProperty(key)) {
    //             if (Object.prototype.toString.call(source[key]) === '[object Object]') {
    //                 target[key] = cloneShallow(source[key]);
    //             } else {
    //                 target[key] = source[key];
    //             }
    //         }
    //     }
    //     return target;
    // }

    // // 测试用例
    // var a = {
    //     name: "muyiy",
    //     book: {
    //         title: "You Don't Know JS",
    //         price: "45"
    //     },
    //     array: ['苏英大', '1', '2'],
    //     a1: undefined,
    //     a2: null,
    //     a3: 123
    // }
    // var b = cloneShallow(a);

    // a.name = "高级前端进阶";
    // a.book.price = "修改成功";
    // a.array[1] = '修改成功苏英大';

    // console.log(b);
    // {
    //   name: 'muyiy',
    //   book: { title: 'You Don\'t Know JS', price: '55' },
    //   a1: undefined,
    //   a2: null,
    //   a3: 123
    // }

    /*  //async函数写法
     function fun1(value) {
         return new Promise((resolve, reject) => {
             // resolve(value++)
             // console.log(value++)
             setTimeout(function(callback) {
                 resolve(value++)
             }, 2000);
         })
     }

     async function asy() {
         let v = 0
         v = await fun1(v)
         console.log(v, '1')
         v = await fun1(v)
         console.log(v, '2')
         v = await fun1(v)
         console.log(v, 'finally')
     }
     asy() //4 */

    /*   var result = bar.bind(foo, 'An') //预置了部分参数'An'
     result(22, '家里蹲大学') //这个参数会和预置的参数合并到一起放入bar中


             var value = 'v in window';

             function func(a, b, c) {
                 console.log(this.value);
                 console.log(a, b, c);
             }
             var obj = {
                 value: 'v in obj'
             };
             Function.prototype.bind = function(obj, params) {
                 var that = this;
                 var args = [].splice.call(arguments, 1);
                 return function() {
                     var newArgs = [].splice.call(arguments, 0); //将newFunc的参数变成数组
                     that.apply(obj, args.concat(newArgs)); //将上面的数组和之前的参数数组结合
                 }
             }
             var newFunc = func.bind(obj, '参数', '参数2', '参数3');
             newFunc('第二个'); */
    /*var length = 10;

    function fn() {
        console.log(this.length)
    };
    var obj = {
        length: 5,
        method: function (fn) {
            fn();
            arguments[0]();
            fn.call(obj, 1, 3, 3, 4, 5, 112);
        }
    };
    obj.method(fn, 1);*/


    /*var Obj1 = {name: "o1"};
    var Obj2 = new Object(Obj1);
    console.log(Obj2.__proto__ === Object.prototype)
    var a = {a: 1};
    var a1 = Object.create(a);
    a1.a = 2
    console.log(a.a)
    console.log(a1.a)
    console.log(a1.__proto__ === a)*/

    /*     Object.prototype.a = 'a';
         Function.prototype.a = 'a1';
         function Person(){};
         var yideng = new Person();
         console.log('p.a:'+yideng.a);
         console.log(Person.prototype.__proto__.constructor.constructor)
         console.log(yideng.__proto__.__proto__ === Object.prototype);
         console.log( Object.prototype.constructor);
         console.log(yideng.__proto__.__proto__.constructor.constructor.constructor.constructor);*/
    // Object.prototype  Function.prototype
    /*     function Parent() {
                            this.a = 1;
                            this.b = [1, 2, this.a];
                            this.c = {
                                demo: 5
                            };
                            this.show = function() {
                                console.log(this.a, this.b, this.c.demo);
                            }
                        }

                        function Child() {
                            this.a = 2;
                            this.change = function() {
                                this.b.push(this.a);
                                this.a = this.b.length;
                                this.c.demo = this.a++;
                            }
                        }
                        Child.prototype = new Parent();
                        var parent = new Parent();
                        var child1 = new Child();
                        var child2 = new Child();

                        child1.a = 11;
                        child2.a = 12;

                        parent.show(); //1  [1,2,1] 5
                        child1.show(); //  11 [1,2,1] 5
                        child2.show(); //12 [1,2,1] 5
                        child1.change(); //5 [1,2,1,11]   4
                        child2.change(); //6  [1,2,1,11,12]   5
                        parent.show();
                        child1.show(); //5  [1,2,1,11,12]  5
                        child2.show(); //6  [1,2,1,11,12]  5 */


    /*  function SuperType(name, age) {
         this.age = age;
         this.name = name; //实例属性使用借用构造函数模式　　　　　　　　　　　　　　 this.age=age;//实例属性使用借用构造函数模式
         this.colors = ["red", "blue", "green"]; //这个数组虽然会同时被原型链和借用构造函数添加使用，但最后根据原型链的搜索机制，是按照借用构造函数模式实现的。
     }
     SuperType.prototype.sayName = function() {
         console.log(this.name, this.age); //实现同样效果的方法使用原型链模式
     };

     function SubType(name, age) {
         SuperType.call(this, name, age); //借用构造函数模式的有点就是可以向子类型构造函数中的超类型构造函数传递参数，这里this的用法很重要

     };
     SubType.prototype = new SuperType(); //使用SuperType的实例来替换为SubType的原型对象
     SubType.prototype.constructor = SubType; // 这句代码即将SubType的原型对象的constructor属性指向SubType，但这一句去掉也不会影响结果。
     SubType.prototype.sayAge = function() {
         console.log(this.age); //在原型对象中定义方法，可以使得该方法实现复用，增强性能
     };
     var instance1 = new SubType("zzw", 21);
     instance1.colors.push("black");
     console.log(instance1.colors); //["red", "blue", "green", "black"]
     instance1.sayName(); //zzw
     instance1.sayAge(); //21
     var instance2 = new SubType("ht", 18);
     console.log(instance2.colors); //["red", "blue", "green"]
     instance2.sayName(); //ht
     instance2.sayAge(); //18 */
    /*   function SuperType() {
          this.property = true;
      }
      SuperType.prototype.getSuperValue = function() {
          return this.property;
      };

      function SubType() {
          this.subproperty = false;
      }
      SubType.prototype.getSuperValue2 = function() {
          return false; //这时在子类型添加的超类型的同名方法，用于覆盖超类型中的方法，因此，最后反悔了false
      }
      SubType.prototype = new SuperType(); //这一句代码即为替换的原型的语句
      SubType.prototype.constructor = SubType


      var instance = new SubType();
      console.log(instance.getSuperValue2()); //false */
</script>
</body>

</html>